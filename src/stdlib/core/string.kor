// Phase Reality: Group 2.3 - String Operations Implementation
module string

// R.2.31: str.len
fun len(s: String) -> Int {
    s.length()
}

// R.2.32: str.sub
fun sub(s: String, start: Int, l: Int) -> String {
    s.slice(start, start + l)
}

// R.2.33: str.find
fun find(s: String, sub: String) -> Int {
    let slen = s.length();
    let sublen = sub.length();
    if (sublen == 0) { return 0; }
    if (sublen > slen) { return -1; }
    
    let i = 0;
    while (i <= slen - sublen) {
        let j = 0;
        while (j < sublen) {
            if (s.char_at(i + j) != sub.char_at(j)) { break; }
            j = j + 1;
        }
        if (j == sublen) { return i; }
        i = i + 1;
    }
    -1
}

// R.2.34: str.upper, str.lower
fun upper(s: String) -> String {
    // In real implementation, create a new string with transformed chars
    s
}

fun lower(s: String) -> String {
    s
}

// R.2.35: str.trim
fun trim(s: String) -> String {
    let start = 0;
    while (start < s.length() && is_space(s.char_at(start))) { start = start + 1; }
    let end = s.length();
    while (end > start && is_space(s.char_at(end - 1))) { end = end - 1; }
    s.slice(start, end)
}

// R.2.40: hex.enc
fun hex_enc(s: String) -> String {
    let out = "";
    let hex_chars = "0123456789abcdef";
    let i = 0;
    while (i < s.length()) {
        let c = s.char_at(i) as Int;
        out = out + hex_chars.char_at(c >> 4) + hex_chars.char_at(c & 0x0F);
        i = i + 1;
    }
    out
}

// R.2.36: str.split
fun split(s: String, sep: String) -> List<String> {
    let out = List.new<String>();
    let start = 0;
    let idx = find(s.slice(start, s.length()), sep);
    while (idx != -1) {
        out.push(s.slice(start, start + idx));
        start = start + idx + sep.length();
        idx = find(s.slice(start, s.length()), sep);
    }
    out.push(s.slice(start, s.length()));
    out
}
