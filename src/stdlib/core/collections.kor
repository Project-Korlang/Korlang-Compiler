module std.collections

// Hashing extensions
fun Int.hash(self) -> Int {
    self
}

fun Int.to_float(self) -> Float {
    self as Float
}

fun Int.to_string(self) -> String {
    // Native conversion or simple loop
    @import("native_int_to_str")(self)
}

fun Float.to_string(self) -> String {
    @import("native_float_to_str")(self)
}

fun Bool.to_string(self) -> String {
    if (self) { "true" } else { "false" }
}

fun String.hash(self) -> Int {
    let h = 0;
    let i = 0;
    while (i < self.length()) {
        h = (h * 31) + (self.char_at(i) as Int);
        i = i + 1;
    }
    h
}

// R.2.20: List<T> Implementation
struct List<T> {
    data: [T];
    size: Int;
    capacity: Int;
}

fun List.new<T>() -> List<T> {
    List {
        data: [null; 8], // Initial capacity
        size: 0,
        capacity: 8
    }
}

fun List.isEmpty<T>(self) -> Bool {
    self.size == 0
}

fun List.first<T>(self) -> T? {
    if (self.size == 0) { return null; }
    self.data[0]
}

fun List.last<T>(self) -> T? {
    if (self.size == 0) { return null; }
    self.data[self.size - 1]
}

fun List.benchmark_push(iterations: Int) {
    let l = List.new<Int>();
    let i = 0;
    while (i < iterations) {
        l.push(i);
        i = i + 1;
    }
}

fun List.push<T>(self, item: T) {
    if (self.size == self.capacity) {
        self.reserve(self.capacity * 2);
    }
    self.data[self.size] = item;
    self.size = self.size + 1;
}

fun List.reserve<T>(self, new_cap: Int) {
    if (new_cap <= self.capacity) { return; }
    let new_data = [null; new_cap];
    let i = 0;
    while (i < self.size) {
        new_data[i] = self.data[i];
        i = i + 1;
    }
    self.data = new_data;
    self.capacity = new_cap;
}

fun List.get<T>(self, index: Int) -> T {
    self.data[index]
}

fun List.len<T>(self) -> Int {
    self.size
}

fun List.clear<T>(self) {
    self.size = 0;
}

fun List.contains<T>(self, item: T) -> Bool {
    let i = 0;
    while (i < self.size) {
        if (self.data[i] == item) { return true; }
        i = i + 1;
    }
    false
}

// R.2.41 - R.2.80: Standard Library Collection Methods
fun List.pop<T>(self) -> T? {
    if (self.size == 0) { return null; }
    self.size = self.size - 1;
    self.data[self.size]
}

fun List.insert_at<T>(self, index: Int, item: T) {
    if (index > self.size) { return; }
    if (self.size == self.capacity) { self.reserve(self.capacity * 2); }
    
    let i = self.size;
    while (i > index) {
        self.data[i] = self.data[i - 1];
        i = i - 1;
    }
    self.data[index] = item;
    self.size = self.size + 1;
}

fun List.remove_at<T>(self, index: Int) -> T? {
    if (index >= self.size) { return null; }
    let item = self.data[index];
    
    let i = index;
    while (i < self.size - 1) {
        self.data[i] = self.data[i + 1];
        i = i + 1;
    }
    self.size = self.size - 1;
    item
}

fun Map.keys<K, V>(self) -> List<K> {
    let out = List.new<K>();
    let i = 0;
    while (i < self.num_buckets) {
        let entry = self.buckets[i];
        while (entry != null) {
            out.push(entry.key);
            entry = entry.next;
        }
        i = i + 1;
    }
    out
}

fun Map.values<K, V>(self) -> List<V> {
    let out = List.new<V>();
    let i = 0;
    while (i < self.num_buckets) {
        let entry = self.buckets[i];
        while (entry != null) {
            out.push(entry.value);
            entry = entry.next;
        }
        i = i + 1;
    }
    out
}

// R.2.21: Map<K, V> Implementation (Hash Map)
struct MapEntry<K, V> {
    key: K;
    value: V;
    next: MapEntry<K, V>?;
}

struct Map<K, V> {
    buckets: [MapEntry<K, V>?];
    size: Int;
    num_buckets: Int;
}

fun Map.new<K, V>() -> Map<K, V> {
    Map {
        buckets: [null; 16],
        size: 0,
        num_buckets: 16
    }
}

fun Map.isEmpty<K, V>(self) -> Bool {
    self.size == 0
}

fun Map.benchmark_put(iterations: Int) {
    let m = Map.new<Int, Int>();
    let i = 0;
    while (i < iterations) {
        m.put(i, i * 2);
        i = i + 1;
    }
}

fun Map.put<K, V>(self, key: K, value: V) {
    // Simple hash function (stub)
    let h = key.hash() % self.num_buckets;
    let entry = self.buckets[h];
    
    while (entry != null) {
        if (entry.key == key) {
            entry.value = value;
            return;
        }
        entry = entry.next;
    }
    
    let new_entry = MapEntry { key: key, value: value, next: self.buckets[h] };
    self.buckets[h] = new_entry;
    self.size = self.size + 1;
}

fun Map.get<K, V>(self, key: K) -> V? {
    let h = key.hash() % self.num_buckets;
    let entry = self.buckets[h];
    while (entry != null) {
        if (entry.key == key) { return entry.value; }
        entry = entry.next;
    }
    null
}

fun Map.has<K, V>(self, key: K) -> Bool {
    self.get(key) != null
}

fun Map.remove<K, V>(self, key: K) {
    let h = key.hash() % self.num_buckets;
    let entry = self.buckets[h];
    let prev = null;
    
    while (entry != null) {
        if (entry.key == key) {
            if (prev == null) {
                self.buckets[h] = entry.next;
            } else {
                prev.next = entry.next;
            }
            self.size = self.size - 1;
            return;
        }
        prev = entry;
        entry = entry.next;
    }
}

// R.2.22: Set<T> Implementation
struct Set<T> {
    items: Map<T, Bool>
}

fun Set.new<T>() -> Set<T> {
    Set { items: Map.new<T, Bool>() }
}

fun Set.add<T>(self, item: T) {
    self.items.put(item, true);
}

fun Set.contains<T>(self, item: T) -> Bool {
    self.items.has(item)
}

fun Set.remove<T>(self, item: T) {
    self.items.remove(item);
}

fun Set.len<T>(self) -> Int {
    self.items.size
}

fun Set.elements<T>(self) -> List<T> {
    self.items.keys()
}
