module std.io

import syscall.dispatcher
import syscall.linux

// R.2.1: print
fun print(val: Any) {
    let s = val.to_string();
    @import("native_write")(1, s.ptr, s.length());
}

// R.2.2: echo
fun echo(val: Any) {
    print(val);
    print("\n");
}

// Error type for I/O operations
enum IoError {
    NotFound,
    PermissionDenied,
    AlreadyExists,
    WouldBlock,
    Other(Int)
}

struct IoResult<T> {
    ok: T?,
    err: IoError?
}

fun IoResult.unwrap<T>(self) -> T {
    if (self.err != null) {
        panic("IoError: " + self.err.to_string());
    }
    self.ok
}

struct File {
    fd: Int
}

fun open(path: String, mode: Int) -> IoResult<File> {
    let fd = dispatcher.syscall3(linux.SYS_OPEN, path.ptr, mode, 0);
    if (fd < 0) {
        return IoResult { ok: null, err: IoError.Other(-fd) };
    }
    IoResult { ok: File { fd: fd }, err: null }
}

fun File.read(self, buffer: [u8]) -> IoResult<Int> {
    let n = dispatcher.syscall3(linux.SYS_READ, self.fd, buffer.ptr, buffer.len);
    if (n < 0) {
        return IoResult { ok: null, err: IoError.Other(-n) };
    }
    IoResult { ok: n, err: null }
}

fun File.write(self, data: [u8]) -> IoResult<Int> {
    let n = dispatcher.syscall3(linux.SYS_WRITE, self.fd, data.ptr, data.len);
    if (n < 0) {
        return IoResult { ok: null, err: IoError.Other(-n) };
    }
    IoResult { ok: n, err: null }
}

fun File.close(self) {
    dispatcher.syscall1(linux.SYS_CLOSE, self.fd);
}
