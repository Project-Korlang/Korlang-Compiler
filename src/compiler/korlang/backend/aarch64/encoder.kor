// Native AArch64 instruction encoder (subset)

module compiler.backend.aarch64.encoder

struct ByteBuf {
  bytes: List<UInt>;
}

fun ByteBuf_new() -> ByteBuf {
  ByteBuf { bytes: List.new() }
}

fun emit_u32(buf: ByteBuf, v: UInt) {
  buf.bytes.push(v & 0xFF);
  buf.bytes.push((v >> 8) & 0xFF);
  buf.bytes.push((v >> 16) & 0xFF);
  buf.bytes.push((v >> 24) & 0xFF);
}

// AArch64: Most instructions are 32-bit fixed width

// ADD (extended register) - simple version
fun enc_add_rr(buf: ByteBuf, rd: UInt, rn: UInt, rm: UInt) {
  // 31:sf(1), 30-24:op(0001011), 21:0, 20-16:rm, 15-10:option/imm, 9-5:rn, 4-0:rd
  let instr = 0x8B000000;
  instr = instr | (rm << 16) | (rn << 5) | rd;
  emit_u32(buf, instr);
}

fun enc_sub_rr(buf: ByteBuf, rd: UInt, rn: UInt, rm: UInt) {
  let instr = 0xCB000000;
  instr = instr | (rm << 16) | (rn << 5) | rd;
  emit_u32(buf, instr);
}

fun enc_mul_rr(buf: ByteBuf, rd: UInt, rn: UInt, rm: UInt) {
  let instr = 0x9B007C00;
  instr = instr | (rm << 16) | (rn << 5) | rd;
  emit_u32(buf, instr);
}

fun enc_ret(buf: ByteBuf) {
  emit_u32(buf, 0xD65F03C0);
}

// MOV (register) -> ORR rd, xzr, rm
fun enc_mov_rr(buf: ByteBuf, rd: UInt, rm: UInt) {
  let xzr = 31;
  let instr = 0xAA0003E0; // ORR Xd, XZR, Xm
  instr = (instr & 0xFFE0FFFF) | (rm << 16);
  instr = (instr & 0xFFFFFFE0) | rd;
  emit_u32(buf, instr);
}
