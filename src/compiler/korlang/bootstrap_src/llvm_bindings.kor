// Self-hosted LLVM bindings and IR emission

module llvm

import kir
import ast

// FFI declarations (placeholders for LLVM C API)
struct LLVMContext {
}
struct LLVMModule {
}
struct LLVMBuilder {
}
struct LLVMType {
}
struct LLVMValue {
}

fun llvm_init() -> Bool
fun llvm_create_context() -> LLVMContext
fun llvm_create_module(ctx: LLVMContext, name: String) -> LLVMModule
fun llvm_create_builder(ctx: LLVMContext) -> LLVMBuilder
fun llvm_i64_type(ctx: LLVMContext) -> LLVMType
fun llvm_f64_type(ctx: LLVMContext) -> LLVMType
fun llvm_void_type(ctx: LLVMContext) -> LLVMType
fun llvm_pointer_type(ty: LLVMType) -> LLVMType
fun llvm_function_type(ret: LLVMType, params: List<LLVMType>) -> LLVMType
fun llvm_add_function(module: LLVMModule, name: String, fnty: LLVMType) -> LLVMValue
fun llvm_build_ret(builder: LLVMBuilder, value: LLVMValue?) -> LLVMValue
fun llvm_build_call(builder: LLVMBuilder, fn: LLVMValue, args: List<LLVMValue>) -> LLVMValue
fun llvm_write_bitcode(module: LLVMModule, path: String) -> Bool

// Real implementation for now: textual LLVM IR emission.

fun emit_llvm_ir(mod: KirModule) -> String

fun emit_llvm_ir(mod: KirModule) -> String {
  let out = " ";
  let i = 0;
  while (i < mod.functions.len()) {
    out = out + emit_fn(mod.functions[i]);
    i = i + 1;
  }
  out
}

fun emit_fn(f: KirFunction) -> String {
  let ret = emit_ty(f.ret);
  let params = " ";
  let i = 0;
  while (i < f.params.len()) {
    let p = f.params[i];
    let frag = emit_ty(p.ty) + " %" + p.name;
    params = params + (if (i == 0) { frag } else { ", " + frag });
    i = i + 1;
  }
  let body = " ";
  let b = 0;
  while (b < f.blocks.len()) {
    body = body + f.blocks[b].label + ":\n" + emit_block(f.blocks[b]);
    b = b + 1;
  }
  "define " + ret + " @" + f.name + "(" + params + ") \{\n" + body + "\}\n\n"
}

fun emit_block(b: KirBlock) -> String {
  let out = " ";
  let i = 0;
  while (i < b.instrs.len()) {
    out = out + "  " + emit_instr(b.instrs[i]) + "\n";
    i = i + 1;
  }
  out
}

fun emit_instr(i: KirInstr) -> String {
  match (i) {
    KirInstr.Return(v) => if (v != null) { "ret " + emit_ty(v.ty()) + " " + emit_val(v) } else { "ret void" }
    KirInstr.Let(name, ty, v) => name + " = add " + emit_ty(ty) + " " + emit_val(v) + ", 0"
    KirInstr.Assign(name, v) => name + " = add " + emit_ty(v.ty()) + " " + emit_val(v) + ", 0"
    KirInstr.Call(name, args) => {
      let params = " ";
      let j = 0;
      while (j < args.len()) {
        let frag = emit_ty(args[j].ty()) + " " + emit_val(args[j]);
        params = params + (if (j == 0) { frag } else { ", " + frag });
        j = j + 1;
      }
      "call void @" + name + "(" + params + ")"
    }
    KirInstr.Branch(label) => "br label %" + label
    KirInstr.CondBranch(v, t, f) => "br i1 " + emit_val(v) + ", label %" + t + ", label %" + f
    _ => " "
  }
}

fun emit_val(v: KirValue) -> String {
  match (v) {
    KirValue.Reg(n, _) => n
    KirValue.Const(lit, _) => match (lit) {
      Literal.Int(x) => x.to_string()
      Literal.Float(x) => x.to_string()
      Literal.Char(x) => x.to_string()
      Literal.Bool(x) => if (x) { "1" } else { "0" }
      Literal.String(_) => "null"
    }
  }
}

fun emit_ty(t: KirType) -> String {
  match (t) {
    KirType.Int => "i64"
    KirType.UInt => "i64"
    KirType.Float => "double"
    KirType.Bool => "i1"
    KirType.Char => "i32"
    KirType.String => "i8*"
    KirType.Array(inner) => emit_ty(inner) + "*"
    KirType.Tuple(_) => "i8*"
    KirType.Struct(_) => "i8*"
    KirType.Ptr(inner) => emit_ty(inner) + "*"
    KirType.Void => "void"
  }
}
