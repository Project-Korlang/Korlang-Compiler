use crate::sema::Type;
use crate::diag::Diagnostic;

pub struct RustTraitMapper;

impl RustTraitMapper {
    /// Maps a Korlang interface to a Rust trait representation
    pub fn map_interface_to_trait(interface_name: &str, methods: &[String]) -> String {
        let mut rust_code = format!("pub trait {} {{\n", interface_name);
        for method in methods {
            rust_code.push_str(&format!("    fn {}(&self);\n", method));
        }
        rust_code.push_str("}\n");
        rust_code
    }

    pub fn generate_extern_c_wrappers(func_name: &str, params: &[Type], ret: &Type) -> String {
        let mut rust_code = format!("#[no_mangle]\npub extern \"C\" fn korlang_{}(", func_name);
        for (i, param) in params.iter().enumerate() {
            if i > 0 { rust_code.push_str(", "); }
            let rust_ty = match param {
                Type::Int => "i64",
                Type::Float => "f64",
                Type::String => "*const libc::c_char",
                _ => "*mut libc::c_void",
            };
            rust_code.push_str(&format!("arg{}: {}", i, rust_ty));
        }
        let rust_ret = match ret {
            Type::Unit => "",
            Type::Int => " -> i64",
            _ => " -> *mut libc::c_void",
        };
        rust_code.push_str(&format!("){} {{\n    // Implementation generated by Korlang FFI\n}}\n", rust_ret));
        rust_code
    }

    pub fn validate_rust_type(ty: &Type) -> Result<(), String> {
        match ty {
            Type::Func(_, _) => Ok(()),
            Type::Named(_) => Ok(()),
            Type::Generic(_, _) => Ok(()),
            _ => Err(format!("Type {:?} is not directly representable in Rust FFI", ty)),
        }
    }
}
