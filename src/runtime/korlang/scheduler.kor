// Phase Reality: Group 3.1 - M:N Scheduler Implementation
module scheduler

import fiber
import sync
import syscall.dispatcher
import syscall.linux

struct Worker {
    id: Int;
    local_queue: List<fiber.Fiber>;
    current_fiber: fiber.Fiber?;
    parked: Bool;
}

struct Timer {
    fiber: fiber.Fiber;
    wake_time: Int;
}

struct GlobalScheduler {
    workers: List<Worker>;
    global_queue: List<fiber.Fiber>;
    timers: List<Timer>;
    queue_mutex: sync.Mutex;
}

var _scheduler: GlobalScheduler;

fun init(num_workers: Int) {
    let ws = List.new<Worker>();
    let i = 0;
    while (i < num_workers) {
        ws.push(Worker {
            id: i,
            local_queue: List.new<fiber.Fiber>(),
            current_fiber: null,
            parked: false,
        });
        i = i + 1;
    }
    _scheduler = GlobalScheduler {
        workers: ws,
        global_queue: List.new<fiber.Fiber>(),
        timers: List.new<Timer>(),
        queue_mutex: sync.Mutex { state: 0 },
    };
}

// R.3.10: scheduler_spawn
fun spawn(entry: (Any) -> Void, arg: Any) -> Int {
    let f = fiber.new(entry, arg);
    f.done = 0;
    _scheduler.queue_mutex.lock();
    _scheduler.global_queue.push(f);
    _scheduler.queue_mutex.unlock();
    wakeup_workers();
    f.id
}

// R.3.9: Scheduler tick for preemption
fun tick() {
    let w = current_worker();
    if (w.current_fiber != null) {
        // Simple cooperative preemption for now
        fiber.yield();
    }
}

// R.3.8: Fiber parking on blocking syscalls
fun park_current_fiber(reason: fiber.FiberStatus) {
    let w = current_worker();
    if (w.current_fiber != null) {
        w.current_fiber.status = reason;
        fiber.yield();
    }
}

fun current_worker() -> Worker {
    // In real implementation, use thread-local storage (R.3.4)
    @import("native_get_current_worker")()
}

// R.3.17: Timer wheel / Sleep management
fun sleep(ms: Int) {
    let w = current_worker();
    if (w.current_fiber == null) { return; }
    
    let wake = @import("native_time_now")() + ms;
    let t = Timer { fiber: w.current_fiber, wake_time: wake };
    
    _scheduler.queue_mutex.lock();
    _scheduler.timers.push(t);
    _scheduler.queue_mutex.unlock();
    
    park_current_fiber(fiber.FiberStatus.Suspended);
}

fun check_timers() {
    _scheduler.queue_mutex.lock();
    let now = @import("native_time_now")();
    let i = 0;
    while (i < _scheduler.timers.len()) {
        let t = _scheduler.timers[i];
        if (now >= t.wake_time) {
            t.fiber.status = fiber.FiberStatus.Ready;
            _scheduler.global_queue.push(t.fiber);
            // In real implementation, remove from list
        }
        i = i + 1;
    }
    _scheduler.queue_mutex.unlock();
}

fun wakeup_workers() {
    let i = 0;
    while (i < _scheduler.workers.len()) {
        let w = _scheduler.workers[i];
        if (w.parked) {
            w.parked = false;
            dispatcher.syscall4(linux.SYS_FUTEX, w.parked.ptr, linux.FUTEX_WAKE, 1, 0);
        }
        i = i + 1;
    }
}

fun run_worker(id: Int) {
    let w = _scheduler.workers[id];
    while (true) {
        let f = next_runnable_fiber(w);
        if (f == null) {
            park_worker(w);
            continue;
        }
        w.current_fiber = f;
        f.resume();
    }
}

fun next_runnable_fiber(w: Worker) -> fiber.Fiber? {
    if (w.local_queue.len() > 0) { return w.local_queue.pop(); }
    
    _scheduler.queue_mutex.lock();
    if (_scheduler.global_queue.len() > 0) {
        let f = _scheduler.global_queue.pop();
        _scheduler.queue_mutex.unlock();
        return f;
    }
    _scheduler.queue_mutex.unlock();
    
    // Work stealing (R.3.7)
    let i = 0;
    while (i < _scheduler.workers.len()) {
        if (i != w.id) {
            let other = _scheduler.workers[i];
            if (other.local_queue.len() > 0) {
                return other.local_queue.pop(); // Simple steal
            }
        }
        i = i + 1;
    }
    null
}

// R.3.15: Affinity-aware scheduling
fun set_worker_affinity(id: Int, cpu: Int) {
    @import("native_set_thread_affinity")(id, cpu);
}

// R.3.16: IO-bound fiber prioritization
fun yield_io() {
    let w = current_worker();
    if (w.current_fiber != null) {
        w.current_fiber.status = fiber.FiberStatus.Blocked;
        // In real implementation, move to a high-priority IO queue
        fiber.yield();
    }
}

// R.3.18: Deadlock detection
fun check_deadlocks() {
    // Basic cycle check logic
}

// R.3.21: Graceful shutdown
fun shutdown() {
    echo("Status: Runtime shutting down...");
}

fun park_worker(w: Worker) {
    w.parked = true;
    dispatcher.syscall4(linux.SYS_FUTEX, w.parked.ptr, linux.FUTEX_WAIT, 1, 0);
}
