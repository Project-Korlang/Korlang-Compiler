// Native Korlang runtime: generational heap (logical model)

module runtime.gc

struct HeapObject {
  id: UInt;
  size: UInt;
  gen: UInt; // 0 = young, 1 = old
  marked: Bool;
  fields: List<UInt>;
}

struct Generation {
  objects: List<HeapObject>;
  bytes: UInt;
  threshold: UInt;
}

struct Heap {
  young: Generation;
  old: Generation;
  next_id: UInt;
  roots: List<UInt>;
  remembered: List<UInt>; // old objects that may reference young
}

const GEN_YOUNG: UInt = 0;
const GEN_OLD: UInt = 1;

fun Heap_new(young_threshold: UInt, old_threshold: UInt) -> Heap {
  Heap {
    young: Generation { objects: List.new(), bytes: 0, threshold: young_threshold },
    old: Generation { objects: List.new(), bytes: 0, threshold: old_threshold },
    next_id: 1,
    roots: List.new(),
    remembered: List.new(),
  }
}

fun heap_add_root(heap: Heap, id: UInt) {
  heap.roots.push(id);
}

fun heap_remove_root(heap: Heap, id: UInt) {
  heap.roots = list_remove_uint(heap.roots, id);
}

fun heap_alloc(heap: Heap, size: UInt, field_count: UInt) -> UInt {
  let id = heap.next_id;
  heap.next_id = heap.next_id + 1;
  let fields = List.new();
  let i = 0;
  while (i < field_count) { fields.push(0); i = i + 1; }
  let obj = HeapObject { id: id, size: size, gen: GEN_YOUNG, marked: false, fields: fields };
  heap.young.objects.push(obj);
  heap.young.bytes = heap.young.bytes + size;
  if (heap.young.bytes > heap.young.threshold) {
    heap_collect_young(heap);
  }
  id
}

fun heap_write_barrier(heap: Heap, owner: UInt, child: UInt) {
  if (is_in_generation(heap, owner, GEN_OLD) && is_in_generation(heap, child, GEN_YOUNG)) {
    if (!list_contains(heap.remembered, owner)) {
      heap.remembered.push(owner);
    }
  }
}

fun heap_collect_young(heap: Heap) {
  let i = 0;
  while (i < heap.roots.len()) {
    mark_from(heap, heap.roots[i]);
    i = i + 1;
  }
  let r = 0;
  while (r < heap.remembered.len()) {
    mark_from(heap, heap.remembered[r]);
    r = r + 1;
  }
  sweep_generation(heap, GEN_YOUNG);
  heap.remembered = List.new();
}

fun heap_collect_full(heap: Heap) {
  let i = 0;
  while (i < heap.roots.len()) {
    mark_from(heap, heap.roots[i]);
    i = i + 1;
  }
  sweep_generation(heap, GEN_YOUNG);
  sweep_generation(heap, GEN_OLD);
  heap.remembered = List.new();
}

fun mark_from(heap: Heap, id: UInt) {
  let obj = find_object(heap, id);
  if (obj == null) { return; }
  if (obj.marked) { return; }
  obj.marked = true;
  let i = 0;
  while (i < obj.fields.len()) {
    let child = obj.fields[i];
    if (child != 0) { mark_from(heap, child); }
    i = i + 1;
  }
}

fun sweep_generation(heap: Heap, gen: UInt) {
  let g = if (gen == GEN_YOUNG) { heap.young } else { heap.old };
  let survivors = List.new();
  let bytes = 0;
  let i = 0;
  while (i < g.objects.len()) {
    let obj = g.objects[i];
    if (obj.marked) {
      obj.marked = false;
      if (gen == GEN_YOUNG && obj.size > 0 && g.bytes > g.threshold / 2) {
        promote_object(heap, obj);
      } else {
        survivors.push(obj);
        bytes = bytes + obj.size;
      }
    }
    i = i + 1;
  }
  let new_gen = Generation { objects: survivors, bytes: bytes, threshold: g.threshold };
  if (gen == GEN_YOUNG) { heap.young = new_gen; } else { heap.old = new_gen; }
}

fun promote_object(heap: Heap, obj: HeapObject) {
  let promoted = HeapObject { id: obj.id, size: obj.size, gen: GEN_OLD, marked: false, fields: obj.fields };
  heap.old.objects.push(promoted);
  heap.old.bytes = heap.old.bytes + obj.size;
  if (heap.old.bytes > heap.old.threshold) {
    heap_collect_full(heap);
  }
}

fun find_object(heap: Heap, id: UInt) -> HeapObject? {
  let i = 0;
  while (i < heap.young.objects.len()) {
    let obj = heap.young.objects[i];
    if (obj.id == id) { return obj; }
    i = i + 1;
  }
  let j = 0;
  while (j < heap.old.objects.len()) {
    let obj = heap.old.objects[j];
    if (obj.id == id) { return obj; }
    j = j + 1;
  }
  null
}

fun is_in_generation(heap: Heap, id: UInt, gen: UInt) -> Bool {
  let g = if (gen == GEN_YOUNG) { heap.young } else { heap.old };
  let i = 0;
  while (i < g.objects.len()) {
    if (g.objects[i].id == id) { return true; }
    i = i + 1;
  }
  false
}

fun list_contains(xs: List<UInt>, v: UInt) -> Bool {
  let i = 0;
  while (i < xs.len()) {
    if (xs[i] == v) { return true; }
    i = i + 1;
  }
  false
}

fun list_remove_uint(xs: List<UInt>, v: UInt) -> List<UInt> {
  let out = List.new();
  let i = 0;
  while (i < xs.len()) {
    if (xs[i] != v) { out.push(xs[i]); }
    i = i + 1;
  }
  out
}
