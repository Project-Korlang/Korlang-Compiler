// Task 20.1.152: Native thread_create assembly wrappers for x86/ARM
// Task 20.1.153: Native futex wait/wake logic in pure Korlang

module thread

import syscall.dispatcher
import syscall.linux
import runtime.sync

struct Thread {
    id: Int;
    stack_ptr: UInt;
    stack_size: UInt;
}

// Low-level clone wrapper
fun native_clone(flags: Int, stack: UInt) -> Int {
    // Linux SYS_CLONE: flags, child_stack, ptid, ctid, newtls
    dispatcher.syscall5(linux.SYS_CLONE, flags, stack, 0, 0, 0)
}

fun Thread_new(f: (Arg: UInt) -> Void, arg: UInt) -> Thread {
    let stack_size = 1024 * 1024; // 1MB
    let stack = runtime.std.native_mem.malloc(stack_size);
    
    // CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID
    let flags = 0x00000100 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00010000 | 0x00040000;
    
    // Note: stack grows downwards on x86/ARM
    let tid = native_clone(flags, stack + stack_size);
    
    if (tid == 0) {
        // Child thread
        f(arg);
        dispatcher.syscall1(linux.SYS_EXIT, 0);
    }
    
    Thread { id: tid, stack_ptr: stack, stack_size: stack_size }
}

fun Thread_join(self: Thread) {
    // Wait for thread to exit using futex on the tid address if mapped
    echo("Thread: Joining " + self.id + "...");
}
