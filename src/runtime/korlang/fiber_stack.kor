// Phase 16.1.3: dynamic fiber stack management

module runtime.fiber_stack

struct FiberStack {
  memory: UInt;
  size: UInt;
  min_size: UInt;
  max_size: UInt;
  used: UInt;
}

fun FiberStack_new(min_size: UInt, max_size: UInt) -> FiberStack {
  FiberStack { memory: 0, size: min_size, min_size: min_size, max_size: max_size, used: 0 }
}

fun stack_reserve(s: FiberStack, bytes: UInt) -> Bool {
  if (s.used + bytes <= s.size) {
    s.used = s.used + bytes;
    return true;
  }
  stack_grow(s, bytes)
}

fun stack_release(s: FiberStack, bytes: UInt) {
  if (bytes >= s.used) {
    s.used = 0;
  } else {
    s.used = s.used - bytes;
  }
  stack_shrink(s);
}

fun stack_grow(s: FiberStack, need: UInt) -> Bool {
  let next = s.size;
  while (next < s.used + need && next < s.max_size) {
    next = next * 2;
  }
  if (next < s.used + need) { return false; }
  s.size = next;
  s.used = s.used + need;
  true
}

fun stack_shrink(s: FiberStack) {
  let next = s.size;
  while (next > s.min_size && s.used * 4 < next) {
    next = next / 2;
  }
  if (next < s.min_size) { next = s.min_size; }
  s.size = next;
}
