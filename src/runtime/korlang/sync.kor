// Native Korlang runtime: synchronization primitives (logical model)

module runtime.sync

import runtime.os

struct Mutex {
  locked: Bool;
  owner: UInt;
  waiters: List<UInt>;
}

struct CondVar {
  waiters: List<UInt>;
}

struct AtomicUInt {
  value: UInt;
}

fun Mutex_new() -> Mutex {
  Mutex { locked: false, owner: 0, waiters: List.new() }
}

fun CondVar_new() -> CondVar {
  CondVar { waiters: List.new() }
}

fun AtomicUInt_new(v: UInt) -> AtomicUInt {
  AtomicUInt { value: v }
}

fun mutex_lock(m: Mutex, tid: UInt) -> Bool {
  if (!m.locked) {
    m.locked = true;
    m.owner = tid;
    return true;
  }
  if (m.owner == tid) { return true; }
  m.waiters.push(tid);
  let _ = os_yield();
  false
}

fun mutex_try_lock(m: Mutex, tid: UInt) -> Bool {
  if (!m.locked) {
    m.locked = true;
    m.owner = tid;
    return true;
  }
  false
}

fun mutex_unlock(m: Mutex, tid: UInt) -> Bool {
  if (!m.locked || m.owner != tid) { return false; }
  m.locked = false;
  m.owner = 0;
  // wake one waiter if present
  if (m.waiters.len() > 0) {
    let next = m.waiters[0];
    m.waiters = list_drop_first(m.waiters);
    m.locked = true;
    m.owner = next;
  }
  true
}

fun cond_wait(c: CondVar, m: Mutex, tid: UInt) {
  c.waiters.push(tid);
  let _ = mutex_unlock(m, tid);
  let _ = os_yield();
}

fun cond_signal(c: CondVar) -> UInt {
  if (c.waiters.len() == 0) { return 0; }
  let tid = c.waiters[0];
  c.waiters = list_drop_first(c.waiters);
  tid
}

fun cond_broadcast(c: CondVar) -> List<UInt> {
  let out = c.waiters;
  c.waiters = List.new();
  out
}

fun atomic_load(a: AtomicUInt) -> UInt {
  a.value
}

fun atomic_store(a: AtomicUInt, v: UInt) {
  a.value = v;
}

fun atomic_compare_exchange(a: AtomicUInt, expected: UInt, desired: UInt) -> Bool {
  if (a.value == expected) {
    a.value = desired;
    return true;
  }
  false
}

fun list_drop_first(xs: List<UInt>) -> List<UInt> {
  let out = List.new();
  let i = 1;
  while (i < xs.len()) {
    out.push(xs[i]);
    i = i + 1;
  }
  out
}
